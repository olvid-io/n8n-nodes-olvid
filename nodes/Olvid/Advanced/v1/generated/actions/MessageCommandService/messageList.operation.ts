// @generated by protoc-gen-n8n-actions v1 with parameter "target=ts"
// @generated from file olvid/daemon/services/v1/command_service.proto (package olvid.daemon.services.v1, syntax proto3)
/* eslint-disable */

import { type IExecuteFunctions, type INodeExecutionData, type IDataObject, type INodeProperties, updateDisplayOptions } from 'n8n-workflow';

// noinspection ES6UnusedImports
import { datatypes, OlvidClient, commands } from '@olvid/bot-node';

const properties: INodeProperties[] = [
  {
    displayName: 'Filter',
    name: 'filter',
    type: 'collection',
    default: {
    },
    options: [
      {
        displayName: 'Filter | Type',
        name: 'type',
        type: 'options',

        options: [
          { name: 'TYPE_UNSPECIFIED', value: 'TYPE_UNSPECIFIED' },
          { name: 'TYPE_INBOUND', value: 'TYPE_INBOUND' },
          { name: 'TYPE_OUTBOUND', value: 'TYPE_OUTBOUND' },
        ],
        default: 'TYPE_UNSPECIFIED',
      },
      {
        displayName: 'Filter | DiscussionId',
        name: 'discussionId',
        type: 'number',


        default: 0,
      },
      {
        displayName: 'Filter | SenderContactId',
        name: 'senderContactId',
        type: 'number',


        default: 0,
      },
      {
        displayName: 'Filter | BodySearch',
        name: 'bodySearch',
        type: 'string',


        default: '',
      },
      {
        displayName: 'Filter | Attachment',
        name: 'attachment',
        type: 'options',

        options: [
          { name: 'ATTACHMENT_UNSPECIFIED', value: 'ATTACHMENT_UNSPECIFIED' },
          { name: 'ATTACHMENT_HAVE', value: 'ATTACHMENT_HAVE' },
          { name: 'ATTACHMENT_HAVE_NOT', value: 'ATTACHMENT_HAVE_NOT' },
        ],
        default: 'ATTACHMENT_UNSPECIFIED',
      },
      {
        displayName: 'Filter | Location',
        name: 'location',
        type: 'options',

        options: [
          { name: 'LOCATION_UNSPECIFIED', value: 'LOCATION_UNSPECIFIED' },
          { name: 'LOCATION_HAVE', value: 'LOCATION_HAVE' },
          { name: 'LOCATION_HAVE_NOT', value: 'LOCATION_HAVE_NOT' },
          { name: 'LOCATION_IS_SEND', value: 'LOCATION_IS_SEND' },
          { name: 'LOCATION_IS_SHARING', value: 'LOCATION_IS_SHARING' },
          { name: 'LOCATION_IS_SHARING_FINISHED', value: 'LOCATION_IS_SHARING_FINISHED' },
        ],
        default: 'LOCATION_UNSPECIFIED',
      },
      {
        displayName: 'Filter | MinTimestamp',
        name: 'minTimestamp',
        type: 'number',


        default: 0,
      },
      {
        displayName: 'Filter | MaxTimestamp',
        name: 'maxTimestamp',
        type: 'number',


        default: 0,
      },
      {
        displayName: 'Filter | Reaction',
        name: 'reaction',
        type: 'options',

        options: [
          { name: 'REACTION_UNSPECIFIED', value: 'REACTION_UNSPECIFIED' },
          { name: 'REACTION_HAS', value: 'REACTION_HAS' },
          { name: 'REACTION_HAS_NOT', value: 'REACTION_HAS_NOT' },
        ],
        default: 'REACTION_UNSPECIFIED',
      },
      {
        displayName: 'Filter | ReactionsFilter - List',
        name: 'reactionsFilterList',
        type: 'fixedCollection',
        typeOptions: {
          multipleValues: true,
        },
        default: {},
        options: [
          {
            name: 'collection',
            displayName: 'Collection',
            values: [
              {
                displayName: 'Filter | ReactionsFilter',
                name: 'reactionsFilter',
                type: 'collection',
                default: {
                  reactedBySelect: 'undefined',
                  reactedByMe: false,
                  reactedByContactId: 0,
                },
                options: [
                  {
                    displayName: 'Filter | ReactionsFilter| ReactedByMe',
                    name: 'reactedBySelect',
                    type: 'options',
                    options: [
                      { name: 'Select', value: 'undefined' },
                      { name: 'reactedByMe', value: 'reactedByMe' },
                      { name: 'reactedByContactId', value: 'reactedByContactId' },
                    ],
                    default: 'undefined',
                  },
                  {
                    displayName: 'Filter | ReactionsFilter| ReactedByMe - ReactedByMe',
                    name: 'reactedByMe',
                    type: 'boolean',


                    default: false,
                  },
                  {
                    displayName: 'Filter | ReactionsFilter| ReactedByMe - ReactedByContactId',
                    name: 'reactedByContactId',
                    type: 'number',


                    default: 0,
                  },
                  {
                    displayName: 'Filter | ReactionsFilter| Reaction',
                    name: 'reaction',
                    type: 'string',


                    default: '',
                  },
                ],
              },
            ],
          },
        ],
      },
      {
        displayName: 'Filter | ReplyToAMessage',
        name: 'replySelect',
        type: 'options',
        options: [
          { name: 'Select', value: 'undefined' },
          { name: 'replyToAMessage', value: 'replyToAMessage' },
          { name: 'doNotReplyToAMessage', value: 'doNotReplyToAMessage' },
          { name: 'repliedMessageId', value: 'repliedMessageId' },
        ],
        default: 'undefined',
      },
      {
        displayName: 'Filter | ReplyToAMessage - ReplyToAMessage',
        name: 'replyToAMessage',
        type: 'boolean',


        default: false,
      },
      {
        displayName: 'Filter | ReplyToAMessage - DoNotReplyToAMessage',
        name: 'doNotReplyToAMessage',
        type: 'boolean',


        default: false,
      },
      {
        displayName: 'Filter | ReplyToAMessage - RepliedMessageId',
        name: 'repliedMessageId',
        type: 'collection',
        default: {
          type: 'TYPE_UNSPECIFIED',
          id: 0,
        },
        options: [
          {
            displayName: 'Filter | ReplyToAMessage - RepliedMessageId| Type',
            name: 'type',
            type: 'options',

            options: [
              { name: 'TYPE_UNSPECIFIED', value: 'TYPE_UNSPECIFIED' },
              { name: 'TYPE_INBOUND', value: 'TYPE_INBOUND' },
              { name: 'TYPE_OUTBOUND', value: 'TYPE_OUTBOUND' },
            ],
            default: 'TYPE_UNSPECIFIED',
          },
          {
            displayName: 'Filter | ReplyToAMessage - RepliedMessageId| Id',
            name: 'id',
            type: 'number',


            default: 0,
          },
        ],
      },
    ],
  },
  {
    displayName: 'Unread',
    name: 'unread',
    type: 'boolean',
    required: false,

    default: false,
  },
];

const displayOptions = {
  show: {
    resource: ['MessageCommandService'],
    operation: ['MessageList'],
  },
};

export const description = updateDisplayOptions(displayOptions, properties);

export async function execute(this: IExecuteFunctions, index: number, client: OlvidClient): Promise<INodeExecutionData[]> {
    function getFilter(this: IExecuteFunctions, index: number): datatypes.MessageFilter | undefined {
        const itemFilter = this.getNodeParameter('filter', index) as IDataObject | undefined;
        if (itemFilter === undefined) {
            return undefined;
        }
        function getType(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.MessageId_Type | undefined {
            const value: string | number | undefined = itemMessageFilter['type'] as string | number | undefined;
            if (value === undefined) {
                return undefined;
            }
            if (typeof value == 'number') {
                if (datatypes.MessageId_Type [value] === undefined) {
                    throw new Error('The attachment type "${value}" is not known.');
                }
                return value as datatypes.MessageId_Type;
            }
            else {
                const enumKey = value.replace("TYPE_", "");
                return datatypes.MessageId_Type [enumKey as keyof typeof datatypes.MessageId_Type];
            }
        }
        const type: datatypes.MessageId_Type | undefined = getType.call(this, itemFilter);
        const discussionId: bigint | undefined = itemFilter['discussionId'] ? BigInt(itemFilter['discussionId'] as number) : undefined;
        const senderContactId: bigint | undefined = itemFilter['senderContactId'] ? BigInt(itemFilter['senderContactId'] as number) : undefined;
        const bodySearch: string | undefined = itemFilter['bodySearch'] ? itemFilter['bodySearch'] as string : undefined;
        function getAttachment(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.MessageFilter_Attachment | undefined {
            const value: string | number | undefined = itemMessageFilter['attachment'] as string | number | undefined;
            if (value === undefined) {
                return undefined;
            }
            if (typeof value == 'number') {
                if (datatypes.MessageFilter_Attachment [value] === undefined) {
                    throw new Error('The attachment type "${value}" is not known.');
                }
                return value as datatypes.MessageFilter_Attachment;
            }
            else {
                const enumKey = value.replace("ATTACHMENT_", "");
                return datatypes.MessageFilter_Attachment [enumKey as keyof typeof datatypes.MessageFilter_Attachment];
            }
        }
        const attachment: datatypes.MessageFilter_Attachment | undefined = getAttachment.call(this, itemFilter);
        function getLocation(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.MessageFilter_Location | undefined {
            const value: string | number | undefined = itemMessageFilter['location'] as string | number | undefined;
            if (value === undefined) {
                return undefined;
            }
            if (typeof value == 'number') {
                if (datatypes.MessageFilter_Location [value] === undefined) {
                    throw new Error('The attachment type "${value}" is not known.');
                }
                return value as datatypes.MessageFilter_Location;
            }
            else {
                const enumKey = value.replace("LOCATION_", "");
                return datatypes.MessageFilter_Location [enumKey as keyof typeof datatypes.MessageFilter_Location];
            }
        }
        const location: datatypes.MessageFilter_Location | undefined = getLocation.call(this, itemFilter);
        const minTimestamp: bigint | undefined = itemFilter['minTimestamp'] ? BigInt(itemFilter['minTimestamp'] as number) : undefined;
        const maxTimestamp: bigint | undefined = itemFilter['maxTimestamp'] ? BigInt(itemFilter['maxTimestamp'] as number) : undefined;
        function getReaction(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.MessageFilter_Reaction | undefined {
            const value: string | number | undefined = itemMessageFilter['reaction'] as string | number | undefined;
            if (value === undefined) {
                return undefined;
            }
            if (typeof value == 'number') {
                if (datatypes.MessageFilter_Reaction [value] === undefined) {
                    throw new Error('The attachment type "${value}" is not known.');
                }
                return value as datatypes.MessageFilter_Reaction;
            }
            else {
                const enumKey = value.replace("REACTION_", "");
                return datatypes.MessageFilter_Reaction [enumKey as keyof typeof datatypes.MessageFilter_Reaction];
            }
        }
        const reaction: datatypes.MessageFilter_Reaction | undefined = getReaction.call(this, itemFilter);
        function getReactionsFilter(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.ReactionFilter[] | undefined {
            function getReactionsFilter(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.ReactionFilter {
                const itemReactionsFilter = itemMessageFilter['reactionsFilter'] as IDataObject;
                type reactedByType =
                    { value?: undefined, case: undefined } |
                    { value: boolean, case: "reactedByMe" } |
                    { value: bigint, case: "reactedByContactId" };
                function getReactedBy(this: IExecuteFunctions, itemReactionFilter: IDataObject): reactedByType {
                    const selectedCase: string | undefined = itemReactionFilter['reactedBySelect'] as string | undefined;
                    if (selectedCase === undefined) {
                        return { case: undefined };
                    }

                    if (selectedCase === "reactedByMe") {
                        const reactedByMe: boolean = itemReactionFilter['reactedByMe'] as boolean;
                        return { value: reactedByMe, case: "reactedByMe" };
                    }
                    if (selectedCase === "reactedByContactId") {
                        const reactedByContactId: bigint = BigInt(itemReactionFilter['reactedByContactId'] as number);
                        return { value: reactedByContactId, case: "reactedByContactId" };
                    }
                    return { case: undefined };
                }
                const reactedBy: reactedByType = getReactedBy.call(this, itemReactionsFilter);
                const reaction: string | undefined = itemReactionsFilter['reaction'] ? itemReactionsFilter['reaction'] as string : undefined;
                return new datatypes.ReactionFilter({
                    reaction,
                    reactedBy,
                });
            }
            const reactionsFilterCollectionParent: IDataObject | undefined = itemMessageFilter['reactionsFilterList'] as IDataObject | undefined;
            if (reactionsFilterCollectionParent === undefined) {
                return [];
            }
            const reactionsFilterCollection: IDataObject[] | undefined = reactionsFilterCollectionParent['collection'] as IDataObject[] | undefined;
            if (reactionsFilterCollection === undefined) {
                return [];
            }
            const reactionsFilterList: datatypes.ReactionFilter[] = [];
            for (const itemReactionsFilter of reactionsFilterCollection) {
                const reactionsFilter: datatypes.ReactionFilter = getReactionsFilter.call(this, itemReactionsFilter);
                reactionsFilterList.push(reactionsFilter);
            }
            return reactionsFilterList;
        }
        const reactionsFilter: datatypes.ReactionFilter[] | undefined = getReactionsFilter.call(this, itemFilter);
        type replyType =
            { value?: undefined, case: undefined } |
            { value: boolean, case: "replyToAMessage" } |
            { value: boolean, case: "doNotReplyToAMessage" } |
            { value: datatypes.MessageId, case: "repliedMessageId" };
        function getReply(this: IExecuteFunctions, itemMessageFilter: IDataObject): replyType {
            const selectedCase: string | undefined = itemMessageFilter['replySelect'] as string | undefined;
            if (selectedCase === undefined) {
                return { case: undefined };
            }
            function getRepliedMessageId(this: IExecuteFunctions, itemMessageFilter: IDataObject): datatypes.MessageId {
                const itemRepliedMessageId = itemMessageFilter['repliedMessageId'] as IDataObject;
                function getType(this: IExecuteFunctions, itemMessageId: IDataObject): datatypes.MessageId_Type {
                    const value: string | number = itemMessageId['type'] as string | number;

                    if (typeof value == 'number') {
                        if (datatypes.MessageId_Type [value] === undefined) {
                            throw new Error('The attachment type "${value}" is not known.');
                        }
                        return value as datatypes.MessageId_Type;
                    }
                    else {
                        const enumKey = value.replace("TYPE_", "");
                        return datatypes.MessageId_Type [enumKey as keyof typeof datatypes.MessageId_Type];
                    }
                }
                const type: datatypes.MessageId_Type = getType.call(this, itemRepliedMessageId);
                const id: bigint = BigInt(itemRepliedMessageId['id'] as number);
                return new datatypes.MessageId({
                    type,
                    id,
                });
            }

            if (selectedCase === "replyToAMessage") {
                const replyToAMessage: boolean = itemMessageFilter['replyToAMessage'] as boolean;
                return { value: replyToAMessage, case: "replyToAMessage" };
            }
            if (selectedCase === "doNotReplyToAMessage") {
                const doNotReplyToAMessage: boolean = itemMessageFilter['doNotReplyToAMessage'] as boolean;
                return { value: doNotReplyToAMessage, case: "doNotReplyToAMessage" };
            }
            if (selectedCase === "repliedMessageId") {
                const repliedMessageId: datatypes.MessageId = getRepliedMessageId.call(this, itemMessageFilter);
                return { value: repliedMessageId, case: "repliedMessageId" };
            }
            return { case: undefined };
        }
        const reply: replyType | undefined = getReply.call(this, itemFilter);
        return new datatypes.MessageFilter({
            type,
            discussionId,
            senderContactId,
            bodySearch,
            attachment,
            location,
            minTimestamp,
            maxTimestamp,
            reaction,
            reactionsFilter,
            reply,
        });
    }
    const filter: datatypes.MessageFilter | undefined = getFilter.call(this, index);
    const unread: boolean | undefined = this.getNodeParameter('unread', index) ? this.getNodeParameter('unread', index) as boolean : undefined;

    const containerMessage: commands.MessageListResponse = new commands.MessageListResponse();
    for await (const message of client.stubs.messageCommandStub.messageList({filter, unread})) {
        containerMessage.messages.push(...message.messages);
    }

    return this.helpers.returnJsonArray(containerMessage?.messages.map(e => ({id: {type: datatypes.MessageId_Type[e.id?.type ?? 0], id: Number(e.id?.id)}, discussionId: Number(e.discussionId), senderId: Number(e.senderId), body: e.body, sortIndex: e.sortIndex, timestamp: Number(e.timestamp), attachmentsCount: Number(e.attachmentsCount), repliedMessageId: {type: datatypes.MessageId_Type[e.repliedMessageId?.type ?? 0], id: Number(e.repliedMessageId?.id)}, messageLocation: {type: datatypes.MessageLocation_LocationType[e.messageLocation?.type ?? 0], timestamp: Number(e.messageLocation?.timestamp), latitude: e.messageLocation?.latitude, longitude: e.messageLocation?.longitude, altitude: e.messageLocation?.altitude, precision: e.messageLocation?.precision, address: e.messageLocation?.address}, reactions: e.reactions.map(e => ({contactId: Number(e.contactId), reaction: e.reaction, timestamp: Number(e.timestamp)})), forwarded: e.forwarded, editedBody: e.editedBody}))
);
}
