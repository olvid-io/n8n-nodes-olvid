// @generated by protoc-gen-n8n-actions v1 with parameter "target=ts"
// @generated from file olvid/daemon/services/v1/command_service.proto (package olvid.daemon.services.v1, syntax proto3)
/* eslint-disable */

import { type IExecuteFunctions, type INodeExecutionData, type IDataObject, type INodeProperties, updateDisplayOptions } from 'n8n-workflow';

// noinspection ES6UnusedImports
import { datatypes, OlvidClient, commands } from '@olvid/bot-node';

const properties: INodeProperties[] = [
  {
    displayName: 'DiscussionId',
    name: 'discussionId',
    type: 'number',
    required: true,

    default: 0,
  },
  {
    displayName: 'Body',
    name: 'body',
    type: 'string',
    required: true,

    default: '',
  },
  {
    displayName: 'ReplyId',
    name: 'replyId',
    type: 'collection',
    default: {
    },
    options: [
      {
        displayName: 'ReplyId | Type',
        name: 'type',
        type: 'options',

        options: [
          { name: 'TYPE_UNSPECIFIED', value: 'TYPE_UNSPECIFIED' },
          { name: 'TYPE_INBOUND', value: 'TYPE_INBOUND' },
          { name: 'TYPE_OUTBOUND', value: 'TYPE_OUTBOUND' },
        ],
        default: 'TYPE_UNSPECIFIED',
      },
      {
        displayName: 'ReplyId | Id',
        name: 'id',
        type: 'number',


        default: 0,
      },
    ],
  },
  {
    displayName: 'Ephemerality',
    name: 'ephemerality',
    type: 'collection',
    default: {
    },
    options: [
      {
        displayName: 'Ephemerality | ReadOnce',
        name: 'readOnce',
        type: 'boolean',


        default: false,
      },
      {
        displayName: 'Ephemerality | ExistenceDuration',
        name: 'existenceDuration',
        type: 'number',


        default: 0,
      },
      {
        displayName: 'Ephemerality | VisibilityDuration',
        name: 'visibilityDuration',
        type: 'number',


        default: 0,
      },
    ],
  },
  {
    displayName: 'DisableLinkPreview',
    name: 'disableLinkPreview',
    type: 'boolean',
    required: false,

    default: false,
  },
];

const displayOptions = {
  show: {
    resource: ['MessageCommandService'],
    operation: ['MessageSend'],
  },
};

export const description = updateDisplayOptions(displayOptions, properties);

export async function execute(this: IExecuteFunctions, index: number, client: OlvidClient): Promise<INodeExecutionData[]> {
    const discussionId: bigint = BigInt(this.getNodeParameter('discussionId', index) as number);
    const body: string = this.getNodeParameter('body', index) as string;
    function getReplyId(this: IExecuteFunctions, index: number): datatypes.MessageId | undefined {
        const itemReplyId = this.getNodeParameter('replyId', index) as IDataObject | undefined;
        if (itemReplyId === undefined) {
            return undefined;
        }
        function getType(this: IExecuteFunctions, itemMessageId: IDataObject): datatypes.MessageId_Type | undefined {
            const value: string | number | undefined = itemMessageId['type'] as string | number | undefined;
            if (value === undefined) {
                return undefined;
            }
            if (typeof value == 'number') {
                if (datatypes.MessageId_Type [value] === undefined) {
                    throw new Error('The attachment type "${value}" is not known.');
                }
                return value as datatypes.MessageId_Type;
            }
            else {
                const enumKey = value.replace("TYPE_", "");
                return datatypes.MessageId_Type [enumKey as keyof typeof datatypes.MessageId_Type];
            }
        }
        const type: datatypes.MessageId_Type | undefined = getType.call(this, itemReplyId);
        const id: bigint | undefined = itemReplyId['id'] ? BigInt(itemReplyId['id'] as number) : undefined;
        return new datatypes.MessageId({
            type,
            id,
        });
    }
    const replyId: datatypes.MessageId | undefined = getReplyId.call(this, index);
    function getEphemerality(this: IExecuteFunctions, index: number): datatypes.MessageEphemerality | undefined {
        const itemEphemerality = this.getNodeParameter('ephemerality', index) as IDataObject | undefined;
        if (itemEphemerality === undefined) {
            return undefined;
        }
        const readOnce: boolean | undefined = itemEphemerality['readOnce'] ? itemEphemerality['readOnce'] as boolean : undefined;
        const existenceDuration: bigint | undefined = itemEphemerality['existenceDuration'] ? BigInt(itemEphemerality['existenceDuration'] as number) : undefined;
        const visibilityDuration: bigint | undefined = itemEphemerality['visibilityDuration'] ? BigInt(itemEphemerality['visibilityDuration'] as number) : undefined;
        return new datatypes.MessageEphemerality({
            readOnce,
            existenceDuration,
            visibilityDuration,
        });
    }
    const ephemerality: datatypes.MessageEphemerality | undefined = getEphemerality.call(this, index);
    const disableLinkPreview: boolean | undefined = this.getNodeParameter('disableLinkPreview', index) ? this.getNodeParameter('disableLinkPreview', index) as boolean : undefined;
    const response: commands.MessageSendResponse = await client.stubs.messageCommandStub.messageSend({discussionId, body, replyId, ephemerality, disableLinkPreview});
    return this.helpers.returnJsonArray({id: {type: datatypes.MessageId_Type[response?.message?.id?.type ?? 0], id: Number(response?.message?.id?.id)}, discussionId: Number(response?.message?.discussionId), senderId: Number(response?.message?.senderId), body: response?.message?.body, sortIndex: response?.message?.sortIndex, timestamp: Number(response?.message?.timestamp), attachmentsCount: Number(response?.message?.attachmentsCount), repliedMessageId: {type: datatypes.MessageId_Type[response?.message?.repliedMessageId?.type ?? 0], id: Number(response?.message?.repliedMessageId?.id)}, messageLocation: {type: datatypes.MessageLocation_LocationType[response?.message?.messageLocation?.type ?? 0], timestamp: Number(response?.message?.messageLocation?.timestamp), latitude: response?.message?.messageLocation?.latitude, longitude: response?.message?.messageLocation?.longitude, altitude: response?.message?.messageLocation?.altitude, precision: response?.message?.messageLocation?.precision, address: response?.message?.messageLocation?.address}, reactions: response?.message?.reactions.map(e => ({contactId: Number(e.contactId), reaction: e.reaction, timestamp: Number(e.timestamp)})), forwarded: response?.message?.forwarded, editedBody: response?.message?.editedBody});
}
