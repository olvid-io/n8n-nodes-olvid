import {
	createEcmaScriptPlugin,
	runNodeJs,
	type Schema,
} from '@bufbuild/protoplugin';
import { generateRouterCallOperation } from './files/actions/generateRouterCallOperation';
import type { ResourceOperationListType } from './tools/types';
import { generateActionInterfaces } from './files/actions/generateActionInterfaces';
import { generateActionVersionDescription } from './files/actions/generateActionVersionDescription';
import { generateAction } from './files/actions/generateAction';
import { generateActionIndexes } from './files/actions/generateActionIndexes';
import { listFilesInDirectory } from './tools/files';
import * as path from 'path';
import { overrideFile } from './files/overrideFile';
import { generateTrigger } from './files/triggers/generateTrigger';
import { generateTriggerInterfaces } from './files/triggers/generateTriggerInterfaces';
import { generateTriggerVersionDescription } from './files/triggers/generateTriggerVersionDescription';

const plugin = createEcmaScriptPlugin({
	name: 'protoc-gen-n8n-actions',
	version: 'v1',
	generateTs(schema: Schema) {
		const preamble = `// @generated by ${this.name} ${this.version} with parameter "target=ts"`;
		const actionResourceOperationsList: ResourceOperationListType = {};
		const triggerResourceOperationsList: ResourceOperationListType = {};
		const overrideFileList: string[] = listFilesInDirectory(path.join(__dirname, "overrides"))

		// browse services
		for (const file of schema.files) {
			for (const service of file.services) {
				for (const method of service.methods) {
					// ignore admin services
					if (service.name.endsWith('AdminService')) { }
					// notification services
					else if (service.name.endsWith('NotificationService')) {
						const isOverwritten = overrideFile(schema, overrideFileList, service.name, method.name, "triggers");
						if (!triggerResourceOperationsList[service.name])
							triggerResourceOperationsList[service.name] = [];
						triggerResourceOperationsList[service.name].push(method.name);
						if (!isOverwritten)
							generateTrigger(schema, method);
					}
					// command services
					else if (service.name.endsWith('CommandService')) {
						const isOverwritten = overrideFile(schema, overrideFileList, service.name, method.name, "actions");
						if (!actionResourceOperationsList[service.name])
							actionResourceOperationsList[service.name] = [];
						actionResourceOperationsList[service.name].push(method.name);
						if (!isOverwritten)
							generateAction(schema, method);
					}
					else {
						throw new Error(`#--# GENERATION ERROR: Unrecognized service type for ${service.name}`);
					}
				}
			}
		}
		if (Object.keys(actionResourceOperationsList).length !== 0) {
			// Action Indexes
			for (const resource in actionResourceOperationsList) {
				const actionIndexFile = schema.generateFile(`actions/${resource}/index.ts`);
				actionIndexFile.print(preamble);
				generateActionIndexes(actionIndexFile, actionResourceOperationsList, resource);
			}
			// Action Interfaces
			const interfacesFile = schema.generateFile('actions/generatedInterfaces.ts');
			interfacesFile.print(preamble);
			generateActionInterfaces(interfacesFile, actionResourceOperationsList);
			// Router Call Operation
			const callOperationfile = schema.generateFile('actions/generatedCallOperation.ts');
			callOperationfile.print(preamble);
			generateRouterCallOperation(callOperationfile, actionResourceOperationsList);
			// Action Version Description
			const versionDescriptionFile = schema.generateFile('actions/generatedVersionDescription.ts');
			versionDescriptionFile.print(preamble);
			generateActionVersionDescription(versionDescriptionFile, actionResourceOperationsList);
			// Properties Index
			// const propertiesIndexFile = schema.generateFile('actions/properties/index.ts');
			// propertiesIndexFile.print(preamble);
			// generatePropertiesIndex(propertiesIndexFile, typeList, actionResourceOperationList);
			// Trigger Interfaces
			const triggerInterfacesFile = schema.generateFile('triggers/generatedInterfaces.ts');
			triggerInterfacesFile.print(preamble);
			generateTriggerInterfaces(triggerInterfacesFile, triggerResourceOperationsList);
			// Trigger Version Description
			const triggerVersionDescriptionFile = schema.generateFile('triggers/generatedVersionDescription.ts');
			triggerVersionDescriptionFile.print(preamble);
			generateTriggerVersionDescription(triggerVersionDescriptionFile, triggerResourceOperationsList);
		}
	},
});

// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.
runNodeJs(plugin);
